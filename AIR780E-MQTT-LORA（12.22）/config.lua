--[[
@module config
@summary 配置文件 - 集中管理所有常量和配置参数
@version 1.0.0

================================================================================
LuaOS 基础知识（给有 Python 经验的开发者）
================================================================================

【Lua vs Python 语法对比】
- Lua 用 local 声明局部变量，类似 Python 的局部作用域
- Lua 的 table（表）= Python 的 dict + list 的结合体
- Lua 用 require() 导入模块，类似 Python 的 import
- Lua 函数用 function...end，Python 用 def...（缩进）
- Lua 注释用 --，多行注释用 --[[ ]]
- Lua 数组索引从 1 开始，Python 从 0 开始

【本文件作用】
这个文件是全局配置中心，类似 Python 项目中的 config.py 或 settings.py。
所有硬件参数、通讯参数、业务参数都集中在这里管理。

【为什么要集中配置？】
1. 修改参数时只需要改这一个文件
2. 避免魔法数字（magic number）散落在代码各处
3. 方便不同环境（开发/测试/生产）切换配置
]]

-- 创建一个空的 table（表），用于存储所有配置
-- 类似 Python: config = {}
local config = {}

--------------------------------------------------------------------------------
-- 项目基本信息
-- 这些信息用于固件识别和 FOTA（远程升级）
--------------------------------------------------------------------------------
config.PROJECT = "sczthd_780ehv_bjq_lora"  -- 项目名称，用于合宙云平台识别
config.VERSION = "001.000.000"              -- 固件版本号，FOTA 升级时会检查
config.PRODUCT_KEY = "123"                  -- 产品密钥，用于云平台认证

--------------------------------------------------------------------------------
-- MQTT 配置
-- MQTT 是一种轻量级的消息协议，专为物联网设计
-- 类似 Python 中使用 paho-mqtt 库的配置
--------------------------------------------------------------------------------
config.mqtt = {
    -- 服务器地址和端口
    host = "47.104.166.179",    -- MQTT 服务器 IP（阿里云服务器）
    port = 1883,                 -- MQTT 标准端口（非加密）
    isssl = false,               -- 是否使用 SSL 加密（false=不加密）

    -- 认证信息（类似 HTTP 的 Basic Auth）
    user_name = "mqtt_user",     -- MQTT 用户名
    password = "mqtt_password",  -- MQTT 密码

    -- 心跳保活时间（秒）
    -- 客户端每隔这么长时间发送一次心跳包，告诉服务器"我还活着"
    -- 如果超过 1.5 倍这个时间没有通讯，服务器会认为客户端掉线
    keepalive = 240,  -- 240秒 = 4分钟

    -- MQTT Topic（主题）前缀
    -- MQTT 使用 发布/订阅 模式，Topic 就是消息的"频道"
    -- 实际 Topic = 前缀 + 设备 IMEI，确保每个设备有唯一的通道
    -- 例如：/780EHV/PUB/869329068888888
    pub_topic_prefix = "/780EHV/PUB/",  -- 设备发布消息用的 Topic 前缀
    sub_topic_prefix = "/780EHV/SUB/"   -- 设备订阅消息用的 Topic 前缀
}

--------------------------------------------------------------------------------
-- GPIO 引脚定义
-- GPIO = General Purpose Input/Output，通用输入输出引脚
-- 这些数字是 Air780E 模块上的物理引脚编号
-- 类似 Python 在树莓派上使用 GPIO.BCM 模式的引脚号
--------------------------------------------------------------------------------
config.gpio = {
    -- 【模式选择引脚】
    -- 通过外部跳线或开关控制这个引脚的电平
    -- 低电平(0) = 4G模式（使用MQTT通讯）
    -- 高电平(1) = LORA模式（使用串口+LORA模块通讯）
    MODE_SELECT = 1,

    -- 【LED 控制引脚】
    -- 报警时这些 LED 会同时闪烁
    LED_MAIN = 28,  -- 主 LED（可能是指示灯）
    LED_1 = 34,     -- 报警灯 1
    LED_2 = 35,     -- 报警灯 2
    LED_3 = 36,     -- 报警灯 3
    LED_4 = 37,     -- 报警灯 4
    LED_5 = 38,     -- 报警灯 5

    -- 【音频相关引脚】
    -- PA = Power Amplifier，功率放大器（喇叭驱动芯片）
    -- ES8311 是音频编解码芯片（类似声卡）
    AUDIO_PA = 22,      -- 功放使能引脚，高电平开启喇叭
    AUDIO_POWER = 20,   -- ES8311 电源控制，高电平供电

    -- 【低功耗相关】
    -- 浮空引脚会产生漏电流，需要在休眠前关闭
    FLOAT_INPUT = 23    -- 需要关闭以防止浮空漏电流
}

--------------------------------------------------------------------------------
-- 音频配置
-- 使用 ES8311 音频编解码芯片，通过 I2C 控制，I2S 传输音频数据
-- I2C = 控制总线，用于配置芯片参数
-- I2S = 音频数据总线，用于传输 PCM 音频流
--------------------------------------------------------------------------------
config.audio = {
    -- 总线 ID
    i2c_id = 0,     -- I2C 总线编号（Air780E 有多个 I2C）
    i2s_id = 0,     -- I2S 总线编号

    -- I2S 配置
    i2s_mode = 0,           -- 0=主机模式（Air780E 提供时钟）
    sample_rate = 16000,    -- 采样率 16kHz（语音常用）
    bits_per_sample = 16,   -- 每个采样点 16 位（CD 音质是 16 位）
    channel_format = i2s.MONO_R,  -- 单声道，右声道
    comm_format = i2s.MODE_LSB,   -- LSB 格式（数据位序）
    channel_bits = 16,      -- 每通道位数

    -- 音频通道 ID
    multimedia_id = 0,      -- 多媒体通道编号，用于 audio.play() 等 API

    -- 功放控制参数
    pa_on_level = 1,        -- 功放开启电平（1=高电平有效）
    power_on_level = 1,     -- ES8311 电源开启电平

    -- 时序参数（这些延时很重要，防止开关机时的"啪"声）
    power_delay = 3,        -- DAC 启动前冗余时间，单位 100ms（即 300ms）
    pa_delay = 100,         -- DAC 启动后延迟打开 PA，单位 ms
    power_time_delay = 100, -- PA 与 DAC 关闭间隔，单位 ms

    -- 音量设置（0-100）
    voice_vol = 90,         -- 播放音量
    mic_vol = 80            -- 麦克风增益（本项目可能不用）
}

--------------------------------------------------------------------------------
-- 串口配置（LORA 模式使用）
-- UART = Universal Asynchronous Receiver/Transmitter，通用异步收发器
-- 就是常说的"串口"，类似 Python 的 serial.Serial()
--------------------------------------------------------------------------------
config.uart = {
    id = 1,             -- 串口编号（Air780E 有多个串口，这里用 UART1）
    baudrate = 9600,    -- 波特率（每秒传输 9600 位，常见的低速率）
    databits = 8,       -- 数据位（每帧 8 位数据）
    stopbits = 1        -- 停止位（每帧 1 位停止位）
    -- 注：默认无校验位(parity=none)
}

--------------------------------------------------------------------------------
-- 电源管理配置
-- Air780E 支持 PSM（Power Save Mode），可以将功耗降到微安级别
-- 这对于电池供电的户外设备非常重要
--------------------------------------------------------------------------------
config.power = {
    -- 【看门狗配置】
    -- 看门狗是一个硬件定时器，如果程序卡死不"喂狗"，就会自动重启
    -- 类似服务器上的 systemd 自动重启服务
    -- 【优化】增大超时时间，避免网络操作阻塞时误触发重启
    wdt_timeout = 20000,      -- 看门狗超时时间 20000ms（20秒）
    wdt_feed_interval = 5000, -- 喂狗间隔 5000ms（5秒）
    -- 规则：喂狗间隔必须小于超时时间的一半，保证足够安全余量

    -- 【RTC 定时唤醒】
    -- RTC = Real Time Clock，实时时钟，休眠时仍然运行
    -- 设备会定期被 RTC 唤醒，上报状态后再次休眠
    rtc_wakeup_interval = 6 * 60 * 60 * 1000,  -- 6小时 = 21600000ms

    -- 【雷达唤醒后保持时间】
    -- 雷达检测到人员后唤醒设备，保持清醒一段时间等待报警指令
    -- 避免频繁休眠/唤醒
    radar_keep_awake_time = 30 * 60 * 1000,    -- 30分钟 = 1800000ms

    -- 【雷达唤醒冷却时间】
    -- 在此时间内，如果再次被雷达唤醒，直接进入休眠不处理
    -- 防止雷达频繁触发导致设备无法进入低功耗
    -- 需求：30分钟内不会重复唤醒
    radar_cooldown_time = 30 * 60 * 1000,      -- 30分钟 = 1800000ms

    -- 【PSM 失败超时】
    -- 如果进入 PSM 模式后这么长时间还在运行，说明 PSM 进入失败
    psm_fail_timeout = 15000,  -- 15秒

    -- 【MQTT 连接配置】
    mqtt_connect_timeout = 30000,   -- MQTT 连接超时 30秒
    mqtt_retry_count = 3,           -- MQTT 连接重试次数
    mqtt_retry_interval = 5000      -- MQTT 重试间隔 5秒
}

--------------------------------------------------------------------------------
-- 报警配置
-- 报警时 LED 闪烁 + TTS 语音播报
--------------------------------------------------------------------------------
config.alarm = {
    led_flash_interval = 300,   -- LED 闪烁间隔 300ms（即每秒闪约 3 次）
    tts_repeat_interval = 4000, -- TTS 播报间隔 4000ms（每 4 秒播报一次）
    tts_message = "高液位报警，请立即停止卸油！"  -- 报警语音内容
}

--------------------------------------------------------------------------------
-- LORA 消息协议定义
-- LORA 模式下，设备通过串口与 LORA 模块通讯
-- 使用简单的字符协议（不是 JSON）
--------------------------------------------------------------------------------
config.lora_msg = {
    -- 【接收消息】（从主控制器发来）
    -- 支持单字符和四字符两种格式，增加抗干扰能力
    ALARM = {"C", "CCCC"},      -- 报警指令（C 或 CCCC）
    CANCEL = {"A", "AAAA"},     -- 取消报警指令（A 或 AAAA）
    DISARM = {"B", "BBBB"},     -- 解除报警指令（B 或 BBBB）

    -- 【发送消息】（设备主动上报）
    BATTERY_LOW = "DDDD",       -- 电池电量低
    BATTERY_OK = "EEEE",        -- 电池电量正常

    -- 【电量阈值】
    BATTERY_THRESHOLD = 3300    -- 低电量阈值 3300mV（3.3V）
    -- 锂电池电压范围一般是 3.0V-4.2V，3.3V 大约是 20% 电量
}

--------------------------------------------------------------------------------
-- 唤醒原因定义
-- 设备从休眠中醒来时，需要知道是什么原因唤醒的
-- 不同的唤醒原因，后续处理逻辑不同
--------------------------------------------------------------------------------
config.wakeup = {
    POWER_ON = 0,   -- 上电启动（首次开机或重启）
    RTC = 1,        -- RTC 定时唤醒（定期上报状态）
    IO = 2          -- IO 唤醒（雷达检测到人员 / 串口收到数据）
}

--------------------------------------------------------------------------------
-- 返回配置表
-- 其他模块通过 require("config") 获取这个表
-- 类似 Python 的 from config import config
--------------------------------------------------------------------------------
return config
